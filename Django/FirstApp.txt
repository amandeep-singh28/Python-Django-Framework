*****Creating our first app****
Every django project is a collection of apps.
Check on settings.py, you will see some installed apps.
These apps are by default installed.
INSTALLED_APPS = [
    'django.contrib.admin', -> Admin interface
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions', 
    'django.contrib.messages', -> Displays one time notification to the user
    'django.contrib.staticfiles', -> For serving static files like images, CSS files
]
session -> It is a temporary memory on the server for managing users data. So in these days we don't use this. Remove it
Each app provides a certain functionality.

****How to create own app****
python manage.py startapp <name of app> (playground)
When we create app, every app has the exact same structure.
(i)migrations -> For creating the database tables
(ii)admin module -> How admin interface will be working
(iii)apps module -> Where we configure the apps
(iv)models module -> Where we define model classes for this app, we use this to pull out data from the database and present it to the user
(v)tests module -> For unit tests
(vi)views module -> request handler

****Register for the app****
Everytime, you create a new app, you have to register it on the settings.py file.
Just add the name under INSTALLED APPS 'playground'


****What are views(views.py)****
HTTP is a request response protocol. So every data exchange involves a request and a response. This is where we use VIEWS in Django.

In the views.py, we create view function -> Which takes a request and give a response.
It is a request handler.

->Creating our first view function
Go to your app -> views.py
    from django.http import HttpResponse
    def say_hello(request):
        return HttpResponse("Hello World")

NOTE:-After creating view, we need to map the view to the URL, so when we get a request at that url, this function will be called.

Add a new file in playground named it as urls.py
In this module we are going to map our views
Every app has its own url configuration.

    from django.urls import path
    from . import views

    # URL Configuration module
    urlpatterns = [ # urlpatterns must stay as it is, because Django looks for this only
        path('playground/hello/', views.say_hello)
    ]
views.say_hello -> It means we are not calling it, we are doing it via reference



After doing this, we are goiing to import this URL CONFIGURATION to the main URL CONFIGURATION.
Go to urls.py.
    from django.contrib import admin
    from django.urls import path, include

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('playground/', include('playground.urls')) # This means that any URL which will be start from playground/ do that task only
]

As playground/ is already mentioned, remove it from the urls.py(playground)


****Templates****
Django Templates are used to return HTML pages to the client.
render is used to render a template to the client.
    from django.shortcuts import render
    # Create your views here.
    def say_hello(request):
        return render(request, 'hello.html')
With the help of third parameter (mapping) in render, we can return a string to the HTML page
    return render(request, 'hello.html', {'name' : 'Amandeep'})
In the hello.html
    <h2>Hello {{ name }}</h2>


****Debugging Django Applications in VSCode****
This is useful when our output doesn't matches with the desired output. We can check line by line and see where exactly things are going wrong.
Click on Run & Debug, Create a launch .json file, Select Django.

Open Json file, you will see a dictionary in which configurations are stored
In the args, it is responsible on which port your server will be running, ADD one more port "9000" because on 8000 our previous server is running.

Now go to the Run & debug, add some dummy code in views.py 
def say_hello(request):
    x = 1
    y = 2
    return render(request, 'hello.html', {'name' : 'Amandeep'})
And add a breakpoint at x = 1, this will run the code before x = 1
Now START DEBUGGING, you will see that port number is changed and when you open that link, nothing will be shown because breakpoint is added.
Press f10 to go the next line.
Like this you can debug your Applications.

****NOTE****
Always remove your breakpoints after debugging the code


****Django Debug Tool-Bar****
pipenv install django-debug-toolbar
After doing this, go to Settings.py and add under INSTALLED APPS 'debug_toolbar'    
Add this into the urls.py(storefront) path('__debug__/', include(debug_toolbar.urls))
Add this into MIDDLEWARE(settings.py) "debug_toolbar.middleware.DebugToolbarMiddleware"
Add this INTERNAL IPs:-(Paste it anywhere in the settings.py file)
    INTERNAL_IPS = [
    # ...
    "127.0.0.1",
    # ...
]

****NOTE****
It will only works with proper HTML page.
That's why it is not showing a toolbar because we have only this in out html file
    <h1>Hello World</h1>
    <h2>Hello {{ name }}</h2>

****Models****
python manage.py startapp store
python manage.py startapp tags

Created these two apps, store them in the settings.py file

->Creating Models
Go to store app and open models.py. Create two model classes Product and Customer.

models.Model -> It is a base class that is provided by the django. If you will not inherit it than you will not be able to create database table.

Django automatically creates primary key for every model that we create. If you want to create your own primary key:-
    sku = models.CharField(max_length = 10, primary_key = True)

->Creating Choices
It's like a dropdown
MEMBERSHIP_BRONZE = 'B'
MEMBERSHIP_SILVER = 'S'
MEMBERSHIP_GOLD = 'G'

MEMBERSHIP_CHOICES = [
    (MEMBERSHIP_BRONZE, 'Bronze'),
    (MEMBERSHIP_SILVER, 'Silver'),
    (MEMBERSHIP_GOLD, 'Gold')
]
membership = models.CharField(max_length = 1, choices = MEMBERSHIP_CHOICES, default = MEMBERSHIP_BRONZE)

->Defining One-to-one relationship

class Address(models.Model):
    street = models.CharField(max_length = 255)
    city = models.CharField(max_length = 255)
    customer = models.OneToOneField(Customer, on_delete = models.CASCADE)

(i)models.CASCADE -> It means that when we delete a customer the associate Address will also get deleted.
(ii)models.SET_NULL -> The child database will stay in the database while the customer will set to NULL.
(iii)models.SET_DEFAULT -> When we delete CUSTOMER, its value will be set to some default value while child value will be as it is. (****NOTE**** -> It will only work if the field has a default value defined)
(iv)models.PROTECT -> It protects deletion(Firstly we have to delete the child and then parent).

->Defining One-to-many relationship
Suppose a customer can have same address.
Use ForeignKey and remove the attribute primary_key = True.

class Address(models.Model):
    street = models.CharField(max_length = 255)
    city = models.CharField(max_length = 255)
    customer = models.ForeignKey(Customer, on_delete = models.CASCADE)


****Define One-to-many relationship for this now****
Collection - Product
Customer - Order
Order - Item
Cart - Item

->Defining Many-to-many relationship

Promotion - Product
Created a new model Promotion.

promotions = models.ManyToManyField(Promotion)

->Resolving Circular dependency
It happens when two classes depend on each other at the same time.
In Django, this happens at class definition time because Python executes code top-down.
Product class is going to dependent on the Collection class and at the same time Collection class is going to dependent on the Product class.

As in the Product class, the relationship is already defined between the Collection class (One-to-many)(Product class -> Collection class). 
Now if we try to implement a new relationship from Collection class -> Product class, we will not be able to create it because of CIRCULAR DEPENDENCY(Iska mtlb ye h ki, jo humari COLLECTION class vo access nhi krpaegi PRODUCT class ko, kyuki COLLECTION class os se phele define hai, toh hum PRODUCT class ko access nhi krpaenge).

    class Collection(models.Model):
        featured_product = models.ForeignKey(Product, on_delete = models.SET_NULL, null = True)

    class Product(models.Model):
        collection = models.ForeignKey(Collection, on_delete = models.PROTECT) # From here, Collection is accessible, because it is defined above but we cannot access Product class in the Collection class.

****SOLUTION FOR THIS****
We have to wrap the PRODUCT class in quotes.
    featured_product = models.ForeignKey('Product', on_delete = models.SET_NULL, null = True)

But this introduces a new problem, if tomorrow we decided to rename the PRODUCT class, it will not get reflected in the "featured_product" relationship. But this works.

Now you will encounter another problem which is "REVERSE RELATIONSHIP", as collection relationship is already defined in the PRODUCT class, so Django automatically creates reverse relationship for this. But for the featured_product relationship it will also try to create the reverse relationship but it will not be able to create it because of name clash.
To solve this problem, there are two approaches either rename the name or don't create the reverse relationship for the featured_product:
    (i)featured_product = models.ForeignKey('Product', on_delete = models.SET_NULL, null = True, related_name = 'Product1')
    (ii)featured_product = models.ForeignKey('Product', on_delete = models.SET_NULL, null = True, related_name = '+')


->Generic Relationship
Create two models in Tags app.
    class Tag(models.Model):
        label = models.CharField(max_length = 255)

    class  TaggedItem(models.Model):
        tag = models.ForeignKey(Tag, on_delete = models.CASCADE)
        # Now we need to identify on which object this tag is applied to

As in our APP, there is only one model in the STORE app which is PRODUCT, we can link our tag to product only by importing the product model. 

    from django.db import models
    from store.models import Product # IMPORTED

    # Create your models here.
    class Tag(models.Model):
        label = models.CharField(max_length = 255)

    class  TaggedItem(models.Model):
        tag = models.ForeignKey(Tag, on_delete = models.CASCADE)
        # Now we need to identify on which object this tag is applied to
        product = models.ForeignKey(Product)

But what if there are many other objects like ARTICLES, VIDEOS?????
So, we need a generic way to identify objects.

****SOLUTION****
We need two informations:-
    (i)Type of an object (Product, Video, Article)
    (ii)ID of that object
With these two information we can identify any objects in our application.

content_type  → which model (Product, Article, Video)
object_id     → which row in that model

Use "ContentType", using content type we can create generic relationships between our models. It represents the type of an obejct in our application.

    from django.contrib.contenttypes.models import ContentType
    content_type = models.ForeignKey(ContentType, on_delete = models.CASCADE) # TYPE OF OBJECT

    object_id = models.PositiveIntegerField() # ID
    
    from django.contrib.contenttypes.fields import GenericForeignKey
    content_object = GenericForeignKey() # Actual object


->Create another app likes (python manage.py startapp likes)
App: likes
LikedITem
    - what user likes what object
    - user: ForeignKey to User (django.contrib.auth.models)
    

from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
# Create your models here.

class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete = models.CASCADE) # If a user is deleted, all objects that the user has liked will be deleted
    content_type = models.ForeignKey(ContentType, on_delete = models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()


-> Migrations
Migrations are Django’s way of tracking and applying changes to the database schema.
Models describe the data, migrations apply the changes, database stores it.

****Why Migration is required****
Because database don't change automatically, if we change something in our model, it will not reflect in the database.
Its like updating the database when something got changed in the models.

****Working****
python manage.py makemigrations
It will look at all the installed apps in our project, for each app it will create a new migration file.

Suppose we want to quickly jump onto at some class, use CTRL + T and search it there.

Search PRODUCT and go to the product model, change the name for price -> unit_price by pressing f2. Run "makemigrations" one more time. You will see that it will ask you that "have you changed the column name price to unit_price", if you press "y" than another migration file will be created.

****Note****
If you change the file name for the migration file, than you must update it in another file also.
For example:- In 0002*** migration file:
                    dependencies = [
                    ("store", "0001_initial"),
                    ]
            If you will change the file name of 0001_initial to something else, than you must update it in the 0002 migration file.

****What is Slug??****
Introduced a slug field in the PRODUCT class, for better search engine optimation of our products.

It only contains letters, numbers, underscores and hyphens. It is a search engine optimation technique.
For example:- At a particular web page there is a title ""Django for Beginners!", so slug form will be "django-for-beginners" and its url "/products/django-for-beginners/"

If you will add a slug field in the PRODUCT class and than you will try to run the "migration", than it will not do it, it will ask you for two choice (i)Fill a default value (ii)Exit. If you want to manually fix it than use this:
    # slug = models.SlugField(default = '-')
    # slug = models.SlugField(null = True)
If don't than proceed with the option 1.

You must proceed with the option1, because the default value will only be in the migration not in the main model of the PRODUCT.

